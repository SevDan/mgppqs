MGPPQS Common Development And Operations Standard #1 v.1

1. Goals

There are lot of common problems in product lifecycle that may be fatal and produce huge financial costs. Next recommendations could be useful for all software development & operations teams.

2. Terms

- Quality Assuranse Department - dedicated department or implicit roles of team members who test and monitor product quality.
- Development Department - dedicated or implicit team members who creates new featers in product. (developers, game designers, modellers, event masters etc.)
- Development Game Project - development project (as in PMBOK) in progress of game creation. (before release, first stage of lifecycle)
- Game Product - ready to play game - the result of Development Game Project, game in production with active users and operations processes.
- Vendor - products/services provider with proprietary specific offer.
- Database - software product/solution that serve data storage & operations.
- RDBMS - Relational Database Management System - software product that has a lot of functions to work with databases.

3. Preconditions

Next recommendations could be useful for development game projects & game products both and can be implemented as you want

4. Tags

Common, Development, Operations, Project, Product

5. Body 

There are lot of useful recommendations, but that standard contains only main & critical recommendations. You can implement all this or best part only.

Subjects:

A. Stability
1. Backups
	1.1. State
	1.2. Frequency & Staling
	1.3. Distribution & Verifying
	1.4. Solutions & Tools
2. DevOps 
	2.1. CI/CD
	2.2. Monitoring & Alerting
	2.3. Reliability Engineering
	2.4. Database Maintanence
	2.5. VCS
3. Stable Architechure
	3.1. Bad Practices
	3.2. Legacy Software
4. Code Quality
	4.1. Linters & Automatization
	4.2. Code Review process
	4.3. External Consulting
5. Development Lifecycle
	5.1. Waterfall
	5.2. Agile
	5.3. Other
6. Documentation
	6.1. Product Documents
	6.2. QA Documents
	6.3. Guidelines & Internal information
	6.4. User Guides & Manuals
7. Feedback
	7.1. Support Department
	7.2. Postmortems

B. Security, Permissions, Access
1. OWASP & Principles
2. ISO 27001
	2.1. Information Security Management
3. Database Security
	3.1. Credentials 
	3.2. Schemes
4. Authorization & Authentication
	4.1. Cryptography
	4.2. Password policy
	4.3. Leaks & Trusts 
	4.4. 2 Factor
5. Audit & Rights
	5.1. Code Development
	5.2. External Audit
6. Access
	6.1. SSO
	6.2. Source of Truth
7. Perimissons
	7.1. Levels Model
	7.2. Roles Model
	7.3. ACL Model

C. Critical Information
1. Payment Processes
2. Grant Permissions
3. Logs & Alerts Policy
4. Event Sourcing
	4.1. Events Driven
	4.2. Source of Trurh
	4.3. CQRS
5. Replication & Reliable Infrastructures

D. Commons
1. Departments & Intercommunication
	1.1. Priciples & Delegation
2. Infrustucture
	2.1. Infrastructure Providers
	2.2. Internal Tools & Products
	2.3. Cloud Providers
	2.4. Vendor Locking
3. Team Tools & Software
	3.1. Messangers
	3.2. Project & Product Management
	3.3. Bug Reporting
	3.4. TMS
	3.5. WIKI
4. Marketing Troubleshoting
	4.1. Aggressive Strategies
	4.2. Good Reputation
5. Community Management
	5.1. Product Improvement
	5.2. Technical Feedback
	5.3. Strong Little Groups
6. Financial Profit & Risks
7. Development Communities

		A. Stability
1. Backups
Backup is the result of process that provide you way to get system snapshot on previous time. 
Backups helps you saving your state (data) in fatal cases (i.e. if your server burnt in fire)
Typically backups are only partial of state and represents system state for some time moment.
The most common popular are database backups. All modern RDBMS provide built-in mechanisms to backup your databases.
Another functionality to reliable data storage is replication. But replication cannot replace backuping at all! It's just another factor to make your data safety stored.
Backuping is a extremely important process for stability product. You must do backups and maintain it.

1.1. State
State of any program is a property of data. Software programs can use state for many processes and store it in other locations.
The most popular state that needs to be backuped is persisted state (data saved in database and persisted on disk), but there are a lot of cases where other state should be persisted reliable too (i.e. caches, important attachements, documents, sertificates, cryptography keys and other)

In current standard we will describe database state only.

1.2. Frequency & Staling
If you will do backups too rare it will be invalid. If you will do backups too ofthen it will cost too much to store.
There is good tradeoff is a flexible model with staling.

You should divide your backups for some categories: archived, long term, short term, warm and save it in different locations (please pay attention at this).
a) archived - monthly backups saved for always. The best way to put it into s3 cloude archive storage.
b) long term - weekly backups saved for 6 month (or year). You can put it into object storage too, but maybe you should get more fast storage type.
c) short term - daily backups saved for 2 weeks (or month). You can put it into your dedicated/virtual server (i.e. some NAS)
d) warm - backups with hours frequency (from 30 minutes to 2 hours; or 4-8 hours if you have database replication). You should put it in some other server (or same only for cases if you have RAID-1 or better)

You must automate backuping and staling processes. You can use manually backuping only for addition with automatic.

1.3. Distributing & Verifying 
Backups are not safety stored if it not distributed reliable and not verified. The best way is using automatic backups verification tools (but it can be too difficult or cost too much) - you can automate it with CI/CD scheduling and tests suite, but that process should be maintained by team.

Distribution process has next parts:
1. Do the backup (without downtime if you can)
2. Verify backup has no corruption - files has no obvious errors & mismatches. If it's not, send alerts and try to do it again later (not now! it can take damage to perf)
3. Distribute backup files (i.e. rclone for clouds, rsync for server-to-server)
4. Verify that distribution was complete successfully. If it's not, send alerts and try to do it again later (not now too)

Verification process:
1. Download backup into local verificator (operator or automatic tool) storage
2. Clean local RDBMS
3. Upload backup into local RDBMS with native or external tools
4. Run predefined test suites (should be automated or documented accurately!)
5. If tests passed successfuly, log info into monitoring system about it. If it's not, sends alerts and log details into monitoring system.

1.4. Solutions & Tools
You can use built-in linux utils for backuping process (rsync, crontab, etc.), but you should control quality and reliable of each components if you do it by yourself. You can't trust to whole system if you can't trust to some system component.

More handly way is to use some ready reliable backbone and customize it for your needs. For instance, you can use CI/CD software as automation backbone (i.e. free Jenkins). You will create your own scripts manually, but it will be more comfortable and small, so you will trust it with bigger probability.  

You can built your own monitoring & alerting system based on free Grafana & Prometheus and integrate it with your messenger manually or use proprietary software instead. See more about it in the other topics.

2. DevOps

DevOps is a modern approach to team collaboration. It all about how to get reliable, stable and trustful software products in modern fast world. Some experts thinks that DevOps is a good addition for agile. We will talk about it from the tool side that can help you build reliability and stabilization processes.

2.1. CI/CD
Continuous Integration and Continuous Delivery are approaches to fast development changes delivery. It neccessary principle in agile & devops. One of the part of this approach is a tooling. 

CI tools gives you basics of code quality processes and provide you simple configurable pipelines to automate that processes. You can write your own scripts to easy automate code building, code verifying (with linters, static analysis), code testing (if you write automated test suites for it) and a lot of other features as you need. Of course, as every dedicated product, you should maintain it. But it easy to do, you should change so little part of whole system to change your pipelines. So you can give that work to developers who knowns about code everything.

You should build your code in dedicated solution as CI/CD tools to prevent environment dependencies and you should run all changes over build pipeline to prevent untested code. CI/CD tools is not alone, all of DevOps/agile tools should be used toghether, that how tools gives good profit composely (i.e. you can use CI/CD with Docker to provide atomacity buildings and environment delivery)

As we said earlier, there is a good idea to automate backuping with CI/CD tools.

2.2. Monitoring & Alerting

Monitoring & Alerting is the most important thing in stability. It provides you feedback about your system & fatal errors. So, it provides you knowlage about your system stability.

There are lot of monitoring tools that can be used in other cases. You can use Grafana for most cases. It provides simple API for extentions and can be customized to show your information into dashboards.

The most improtant principle of monitoring is trust. If your monitoring shows wrong information or contains a lot of noise, you can't trust it. So, you should check that all of counting metrics are actual and complete.

Monitoring steps side by side with logging. You should create project logging guidelines and take care about trust to logs. Sometimes you should match logs and monitoring data to successfully troubleshooting. So, you should add same timestamp into your logs as you have it in monitoring.

The second behavior of monitoring is alerting. You should push important (and only important!) alerts to your developers/operations/management when fatal troubles happens.

You can automate it with your corporate messangers (with bots API), emails and SMS-services. Messangers are good and enought for most cases.

2.3 Reliability Engineering

Reliability Engineering is a discipline that implements creating reliable systems. You cannot create reliable and stable system without reliability engineering.
It means your team should contains one dedicated role of reliability engineer (like SRE) or one of team members should take it over implicitly.

Reliability engineering means explicit system risks management. So, reliability engineer should take care of monitoring, backuping, alerting. He must maintain common stability and reliability processes. As result reliability engineering process should determine risks probability and costs. Maybe you should take all new features under reliability engineering analysis. (depends on your needs)

The reliability engineering works with some metrics as SLA, SLO, QoS and some other. If you want to get really reliable and stable product, you should read about it.

2.4. Database Maintanence

If you have RDBMS as database system, you should take care about configs and database features. If you have no DBA role, some of developers/administrators should 
configure database backuping processes, migration (up and down) processes, replication processes.

The best way to maintain procedures, functions and database migrations is put all changes into files in your VCS with project. So, every product version will be equipped with right scripts.

The most simplest way to maintain migrations scripts is store it in lexicographical order in format like 'yyyy-MM-dd-number-title.sql' (i.e. '2021-03-13-1-updateUsersTable-1.sql') grouped by folder or not. Some migration tools & frameworks supports that format (i.e. dbciupdater or Flyway) and some supports custom others (i.e. XML defined schema migration)

Database replication is a good feature that can help you with a lot of problems. 
You can get scalable read load with it and get addition data saving in other servers (in addition with backups). 
So, in some cases if your master database node will shutted down, one of slave node will be switched to master mode and save your application from downtime.

Some NoSQL database provides you custom features with extraordinally effects. In most cases you will get database without ACID transactions. You should be well-known with your tools.

3. Stable Architecture

When you projecting your PoC, you should take care of stability and reliability in future. The most popular way in statups is get PoC as ready product and try to improve it. But problems in architecture may destruct all plans.

3.1. Bad Practices 

Some projects are hopes on other products. You shouldn't do it. Architecture must be reliable to external problems. For instance, your product should be adaptive for game platforom bugs. It means zero trust to external systems in core business logic (i.e. authorization, payment processing).

A lot of realtime configuration and diffuse state is a problem too. As you know, you should do backups and be available to fast recover from any backup. So, if you cant do it because too much runtime configurations should be saved and restored, you losing your reliability.

3.2. Legacy Software

If you use legacy software, the best way to build stable product with it is separate it and use as 3rd party software. There is no way to build good, reliable and controlled architecture over uncontrolled legacy products.

4. Code Quality

-- TODO --

7. Criteria

-- TODO --
-- TODO --

8. Links, Materials & Attachements

Jenkins CI/CD : jenkins.io
Grafana : grafana.com
Prometheus : grafana.com/oss/prometheus
Rclone : rclone.org 
Docker : docker.com
dbciupdater : github.com/SevDan/dbciupdater
Flyway : flywaydb.org
-- TODO --
-- TODO --
 
